import * as ytdl from 'ytdl-core'
import { VoiceConnection, TextChannel, RichEmbed } from 'discord.js'
import CommandContext from 'Handles/Command/CommandContext'

export default class Music {
    servers: {}

    constructor() {
        this.servers = {}
    }

    newServer(serverid) {
        this.servers[serverid] = { queue: [], infos: {}, isPlaying: false, dispatcher: {} }
    }

    addToQueue(url: string, serverid: string, callback: Function) {
        let appthis = this
        if (!this.servers[serverid]) this.newServer(serverid)

        ytdl.getInfo(url)
            .then(infos => {
                appthis.servers[serverid].queue.push(url)
                appthis.servers[serverid].infos[url] = infos
                appthis.servers[serverid].infos[url].duration = this.fancyTimeFormat(parseInt(infos.length_seconds))
                callback(undefined)
            })
            .catch(err => callback(err))
    }

    announceMusic(url: string, context: CommandContext, title: string) {
        let infos = this.servers[context.server.id].infos[url],
            position = this.servers[context.server.id].queue.indexOf(url),
            embed = new RichEmbed()
                .setAuthor(title, context.executor.displayAvatarURL)
                .setTitle(infos.title)
                .setURL(url)
                .addField(context.translate('/music/resp/author'), infos.author.name, true)
                .addField(context.translate('/music/resp/duration'), infos.duration, true)
                .addField(context.translate('/music/resp/position'), (position === 0 ? context.translate('/music/resp/current') : position), true)
                .setImage(infos.thumbnail_url)
        context.reply('', embed)
    }

    playMusic(url: string, connection: VoiceConnection, context: CommandContext) {
        let voiceChan = connection.channel,
            serverid = voiceChan.guild.id,
            server = this.servers[serverid],
            appthis = this

        this.announceMusic(url, context, context.translate('/music/resp/playing'))
        server.dispatcher = connection.playStream(ytdl(url, { quality: 'highestaudio', filter: 'audioonly' }))
        server.isPlaying = true

        server.dispatcher.on('debug', console.log)

        server.dispatcher.on('end', (reason: string) => {
            switch (reason) {
                default:
                    this.newServer(serverid)
                    voiceChan.leave()
                    break
                case 'skip':
                    appthis.delete1thQueueMusic(serverid)
                    let next = appthis.get1thQueueMusicURL(serverid)

                    if (next.startsWith('ERR')) server.dispatcher.end()
                    else appthis.playMusic(next, connection, context)
                    break
            }
        })
    }

    get1thQueueMusicURL(serverid) {
        if (!this.servers[serverid] || !this.servers[serverid].queue[0]) {
            if (!this.servers[serverid]) this.newServer(serverid)
            return 'ERR_NO_MUSIC'
        }
        return this.servers[serverid].queue[0]
    }

    delete1thQueueMusic(serverid) {
        if (!this.servers[serverid]) {
            if (!this.servers[serverid]) this.newServer(serverid)
            return true
        }
        this.servers[serverid].queue.shift()
        return true
    }

    isPlaying(serverid) {
        if (!this.servers[serverid]) if (!this.servers[serverid]) this.newServer(serverid)
        return this.servers[serverid].isPlaying
    }

    fancyTimeFormat(secs: number): string {
        let hours = ~~(secs / 3600),
            minutes = ~~((secs % 3600) / 60),
            seconds = secs % 60,
            ret = ''

        if (hours > 0) ret += '' + hours + ':' + (minutes < 10 ? '0' : '')
        ret += '' + minutes + ':' + (seconds < 10 ? '0' : '') + '' + seconds
        return ret
    }
}
